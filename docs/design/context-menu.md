# コンテキストメニュー設計

## 概要

Selection Command拡張機能のコンテキストメニューに関する設計文書。以下の2つの主要トピックを扱う：

1. **多重階層化**: 現在の1階層構造から、任意の深さを持つ階層構造への拡張
2. **サービスワーカーライフサイクル**: Manifest V3におけるイベントリスナー管理の最適化

## 多重階層化

### 現在の課題

#### 制限事項

- フォルダー階層が1階層のみサポート
- `command.parentFolderId`による単純な親子関係のみ処理
- 既存の`commandTree.ts`の階層構造機能を活用していない

#### 影響

- 複雑なコマンド構造の整理が困難
- ユーザビリティの制約
- オプション画面では多階層対応済みだが、コンテキストメニューでは未対応

### 設計コンセプト

#### 基本方針

1. **階層構造の統一**: `commandTree.ts`の`toCommandTree()`を活用し、オプション画面と同じ階層構造を使用
2. **再帰処理**: 階層の深さに制限を設けず、再帰的にメニューを構築
3. **後方互換性**: 既存の設定データとの互換性を維持

#### アーキテクチャ変更

- **現在**: フラット化処理 → 1階層メニュー作成
- **変更後**: 階層構造保持 → 再帰的メニュー作成

#### データフロー

```
設定データ (commands + folders)
↓
toCommandTree() で階層構造作成
↓
再帰的メニュー作成処理
↓
Chrome Context Menu API
```

### 機能要件

#### フォルダー処理

- フォルダーはサブメニューとして表示
- 空フォルダーも表示（将来の拡張性確保）
- フォルダー内のフォルダーも再帰的に処理

#### コマンド処理

- 各階層のコマンドを実行可能なメニューアイテムとして表示
- 既存のコマンド実行機能との互換性維持

#### 特殊処理

- `OPTION_FOLDER`の区切り線表示機能を維持
- ルートメニューの表示形式を維持

### 単体テスト項目案

#### 基本機能テスト

- **CM-01**: 1階層フォルダー構造の正常作成
  - 期待値: 1階層のフォルダーが正しく表示されること
- **CM-02**: 2階層フォルダー構造の正常作成
  - 期待値: 2階層のフォルダーが正しく表示されること
- **CM-03**: 3階層以上の深い構造の正常作成
  - 期待値: 深い階層のフォルダーが正しく表示されること
- **CM-04**: 空フォルダーの正常表示
  - 期待値: 空のフォルダーが正しく表示されること
- **CM-05**: 設定変更時のメニュー更新
  - 期待値:
    - 設定変更後、メニューが正しく更新されること
    - 変更前のメニューが正しく削除されること

#### コマンド処理テスト

- **CM-06**: ルート直下コマンドの正常作成
  - 期待値: ルート直下のコマンドが正しく表示されること
- **CM-07**: 1階層フォルダー内コマンドの正常作成
  - 期待値: 1階層フォルダー内のコマンドが正しく表示されること
- **CM-08**: 深い階層のコマンドの正常作成
  - 期待値: 深い階層のフォルダ配下へ、コマンドが正しく表示されること
- **CM-09**: 混在構造（フォルダー + コマンド）の正常作成
  - 期待値: フォルダーとコマンドが混在する構造が正しく表示されること

#### 特殊ケーステスト

- **CM-10**: `OPTION_FOLDER`の区切り線表示
  - 期待値: `OPTION_FOLDER`が区切り線として正しく表示されること
- **CM-11**: 循環参照フォルダー構造の処理
  - 期待値: 循環参照が検出された場合、階層の浅いほうのフォルダーに合わせて平坦化されること
- **CM-12**: 存在しない親フォルダー参照の処理
  - 期待値: 存在しない親フォルダーを参照している場合、ルート配下に配置されること

#### 互換性テスト

- **CM-13**: 既存の1階層設定データの正常動作
- **CM-14**: `commandIdObj`マッピングの正常性
- **CM-15**: メニュークリック時のコマンド実行

### 実装上の注意点

#### パフォーマンス

- 階層が深い場合のメニュー作成時間

#### Chrome API制限

- コンテキストメニューの最大項目数制限
- ネストレベルの制限（実装時に確認要）

#### ユーザビリティ

- 深すぎる階層によるユーザビリティ低下の防止
- メニューアイテムの視認性確保

## サービスワーカーライフサイクルとリスナー登録

### 問題の背景

Manifest V3のChrome拡張機能では、バックグラウンド処理がサービスワーカーとして動作する。サービスワーカーは非アクティブ時に自動的に停止し、必要に応じて再起動される仕組みとなっている。

この際、以下の重要な特性がある：

- **コンテキストメニューの構造**: `chrome.contextMenus.create()` で作成されたメニュー項目は永続的に保持される
- **イベントリスナー**: `chrome.contextMenus.onClicked.addListener()` で登録されたリスナーは非永続的で、サービスワーカー停止時に失われる

### 現状の課題

従来の実装では、`ContextMenu.init()` 内で以下の処理を行っていた：

1. 既存のリスナーを削除
2. メニュー構造を再作成
3. 新しいリスナーを登録

この設計では、以下のタイミングでのみリスナーが登録される：

- 拡張機能のインストール/アップデート時（`onInstalled`）
- 設定変更時（`Settings.addChangedListener`）

**問題点:**

- ブラウザ起動時（`onStartup`）にリスナーが登録されない
- サービスワーカーが再起動した際、メニュー構造は残るがリスナーが失われる
- 結果として、ブラウザ起動直後やサービスワーカー再起動後にコンテキストメニューをクリックしても反応しない

### 設計方針

#### 基本原則

1. **メニュー構造とリスナーの分離**: メニュー項目の作成/削除と、イベントリスナーの登録は異なるライフサイクルで管理する
2. **トップレベルでのリスナー登録**: サービスワーカーがロードされるたびに自動的にリスナーが登録されるよう、トップレベルで実行する
3. **責務の明確化**: `ContextMenu.init()` はメニュー構造の初期化のみに専念する

#### アーキテクチャ変更

- **従来**: `init()` 内でリスナー登録 → サービスワーカー再起動時に失われる
- **変更後**: トップレベルでリスナー登録 → サービスワーカーロード時に常に登録される

### ライフサイクルイベントの役割

各イベントハンドラーにおける処理の役割を明確化：

#### `chrome.runtime.onInstalled`

- **実行タイミング**: 拡張機能のインストール、アップデート、Chrome更新時
- **役割**: コンテキストメニュー構造の初期化
- **処理内容**: `ContextMenu.init()` を呼び出してメニュー項目を作成

#### `chrome.runtime.onStartup`

- **実行タイミング**: ブラウザ起動時（プロファイルの読み込み完了後）
- **役割**: 特になし（コンテキストメニュー関連）
- **理由**:
  - メニュー構造は永続的なため再作成不要
  - リスナーはトップレベルで登録されるため追加処理不要

#### トップレベルコード

- **実行タイミング**: サービスワーカーがロードされるたび
- **役割**: イベントリスナーの登録
- **処理内容**: `chrome.contextMenus.onClicked.addListener()` を実行

#### `Settings.addChangedListener`

- **実行タイミング**: 設定が変更されたとき
- **役割**: メニュー構造の再構築
- **処理内容**: `ContextMenu.init()` を呼び出してメニューを更新

### 実装上の考慮事項

#### リスナーの重複登録について

Chrome拡張のAPIは、同一の関数参照で複数回 `addListener()` を呼び出しても、自動的に重複を防ぐ仕組みを持っている。そのため、トップレベルで毎回リスナーを登録しても問題ない。

#### `removeListener` の必要性

トップレベルで一度だけリスナーを登録する設計のため、`init()` 内での `removeListener()` 呼び出しは不要となる。これにより、以下のメリットが得られる：

- コードの簡潔化
- メニュー構造の初期化とリスナー管理の責務分離
- サービスワーカーのライフサイクルに適した設計

#### パフォーマンスへの影響

トップレベルでのリスナー登録は、サービスワーカーのロード時に一度だけ実行されるため、パフォーマンスへの影響は無視できる程度である。
